void lalloc(int x) {
    header = free_list_header;

    while (header != nullptr) {
        if (x > header.size) {
            header = header.next;
            if (header == nullptr)
                return nullptr; //preserves free list, no allocation
            continue; //check next header for fit
        }

        if (x + 32 >= header.size) { //hijack
            header.size = x;

            if (header.next == nullptr && header.prev == nullptr) {
                free_list_header == null;
            } else if (header.next == nullptr && header.prev != nullptr) { //at end of list
                header.prev.next == nullptr;
                header.prev == nullptr;
            } else if (header.next != nullptr && header.prev == nullptr) { //head of list
                header.next.prev == nullptr;
                free_list_header = header.next;
                header.next == nullptr;
            } else {
                header.next.prev = header.prev;
                header.prev.next = header.next;
                header.prev == nullptr;
                header.next == nullptr;
            }

        } else {            
            new_header = header + 32 + x;
            new_header.size = header.size - 32 - x;

            if (header.next == nullptr && header.prev == nullptr) {
                new_header.next = nullptr;
                new_header.prev = nullptr;
                free_list_header = new_header;
            } else if (header.next == nullptr && header.prev != nullptr) { //at end of list
                new_header.next = nullptr;
                new_header.prev = header.prev;
            } else if (header.next != nullptr && header.prev == nullptr) { //head of list
                new_header.next = header.next;
                new_header.prev = nullptr;
                free_list_header = new_header;
            } else {
                new_header.next = header.next;
                new_header.prev = header.prev;
            }
        }

        return header;
    }

    return nullptr;
}

void merge(block p, block n) {
    p->next = n->next;
    n->next->prev = p;
    p->size = c->size + 32;
}

void lfree(void spc) {
    block header = free_list_header;
    block alloc = (struct block *) (spc - 32);

    while (header != nullptr) {
        block p = header->prev;
        block n = header->next;
        
        if (alloc->space > p->space && alloc->space < n->space) {
            alloc->next = n;
            alloc->prev = p;
            p->next = alloc;
            n->prev = alloc;
        } else if (alloc->space < n->space && p == nullptr) {
            alloc->next = n;
            n->prev = alloc;
            free_list_header = alloc;
        } else if (alloc->space > p->space && n == nullptr) {
            alloc->prev = p;
            p->next = alloc;
        } else {
            free_list_header = alloc;
        }
    }

    bool merge_left = alloc->prev->space + alloc->prev->size == alloc;
    bool merge_right = alloc->space + alloc->size == alloc->next;

    if ((p != nullptr && n != nullptr) && (merge_left && merge_right)) {
        merge(alloc->prev, alloc);
        merge(alloc->prev, alloc->next);
    } else if (alloc->prev == nullptr && alloc->next != nullptr && merge_right) {
        merge(alloc, alloc->next);
    } else if (alloc->prev != nullptr && alloc->next == nullptr && merge_left) {
        merge(alloc->prev, alloc);
    } else {
        free_list_header = alloc;
    }
}